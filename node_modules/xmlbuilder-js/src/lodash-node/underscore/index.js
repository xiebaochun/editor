/**
 * @license
 * Lo-Dash 3.0.0-pre (Custom Build) <http://lodash.com/>
 * Build: `lodash modularize underscore exports="node" -o ./underscore/`
 * Copyright 2012-2014 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
var array = require('./array'),
    chain = require('./chain'),
    collection = require('./collection'),
    func = require('./function'),
    lang = require('./lang'),
    object = require('./object'),
    string = require('./string'),
    utility = require('./utility'),
    arrayEach = require('./internal/arrayEach'),
    assign = require('./object/assign'),
    lodash = require('./chain/lodash'),
    lodashWrapper = require('./internal/lodashWrapper'),
    mixin = require('./utility/mixin'),
    support = require('./support');

/** Used as the semantic version number */
var VERSION = '3.0.0-pre';

/** Used for native method references */
var arrayProto = Array.prototype;

// wrap `_.mixin` so it works when provided only one argument
mixin = (function(func) {
  return function(object, source) {
    if (!source) {
      source = object;
      object = lodash;
    }
    return func(object, source);
  };
}(mixin));

// add functions that return wrapped values when chaining
lodash.after = func.after;
lodash.before = func.before;
lodash.bind = func.bind;
lodash.bindAll = func.bindAll;
lodash.chain = chain.chain;
lodash.compact = array.compact;
lodash.constant = utility.constant;
lodash.countBy = collection.countBy;
lodash.debounce = func.debounce;
lodash.defaults = object.defaults;
lodash.defer = func.defer;
lodash.delay = func.delay;
lodash.difference = array.difference;
lodash.drop = array.drop;
lodash.filter = collection.filter;
lodash.flatten = array.flatten;
lodash.forEach = collection.forEach;
lodash.functions = object.functions;
lodash.groupBy = collection.groupBy;
lodash.indexBy = collection.indexBy;
lodash.initial = array.initial;
lodash.intersection = array.intersection;
lodash.invert = object.invert;
lodash.invoke = collection.invoke;
lodash.keys = object.keys;
lodash.map = collection.map;
lodash.matches = utility.matches;
lodash.memoize = func.memoize;
lodash.mixin = mixin;
lodash.negate = func.negate;
lodash.omit = object.omit;
lodash.once = func.once;
lodash.pairs = object.pairs;
lodash.partial = func.partial;
lodash.partition = collection.partition;
lodash.pick = object.pick;
lodash.pluck = collection.pluck;
lodash.property = utility.property;
lodash.range = utility.range;
lodash.reject = collection.reject;
lodash.rest = array.rest;
lodash.shuffle = collection.shuffle;
lodash.sortBy = collection.sortBy;
lodash.take = array.take;
lodash.tap = chain.tap;
lodash.throttle = func.throttle;
lodash.times = utility.times;
lodash.toArray = collection.toArray;
lodash.union = array.union;
lodash.uniq = array.uniq;
lodash.values = object.values;
lodash.where = collection.where;
lodash.without = array.without;
lodash.wrap = func.wrap;
lodash.zip = array.zip;

// add aliases
lodash.collect = collection.map;
lodash.compose = func.flowRight;
lodash.each = collection.forEach;
lodash.extend = assign;
lodash.iteratee = utility.callback;
lodash.methods = object.functions;
lodash.object = array.zipObject;
lodash.select = collection.filter;
lodash.tail = array.rest;
lodash.unique = array.uniq;

// add functions that return unwrapped values when chaining
lodash.clone = lang.clone;
lodash.contains = collection.contains;
lodash.escape = string.escape;
lodash.every = collection.every;
lodash.find = collection.find;
lodash.findWhere = collection.findWhere;
lodash.first = array.first;
lodash.has = object.has;
lodash.identity = utility.identity;
lodash.indexOf = array.indexOf;
lodash.isArguments = lang.isArguments;
lodash.isArray = lang.isArray;
lodash.isBoolean = lang.isBoolean;
lodash.isDate = lang.isDate;
lodash.isElement = lang.isElement;
lodash.isEmpty = lang.isEmpty;
lodash.isEqual = lang.isEqual;
lodash.isFinite = lang.isFinite;
lodash.isFunction = lang.isFunction;
lodash.isNaN = lang.isNaN;
lodash.isNull = lang.isNull;
lodash.isNumber = lang.isNumber;
lodash.isObject = lang.isObject;
lodash.isRegExp = lang.isRegExp;
lodash.isString = lang.isString;
lodash.isUndefined = lang.isUndefined;
lodash.last = array.last;
lodash.lastIndexOf = array.lastIndexOf;
lodash.max = collection.max;
lodash.min = collection.min;
lodash.noConflict = utility.noConflict;
lodash.noop = utility.noop;
lodash.now = utility.now;
lodash.random = utility.random;
lodash.reduce = collection.reduce;
lodash.reduceRight = collection.reduceRight;
lodash.result = utility.result;
lodash.size = collection.size;
lodash.some = collection.some;
lodash.sortedIndex = array.sortedIndex;
lodash.template = string.template;
lodash.unescape = string.unescape;
lodash.uniqueId = utility.uniqueId;

// add aliases
lodash.all = collection.every;
lodash.any = collection.some;
lodash.detect = collection.find;
lodash.foldl = collection.reduce;
lodash.foldr = collection.reduceRight;
lodash.head = array.first;
lodash.include = collection.contains;
lodash.inject = collection.reduce;

// add functions capable of returning wrapped and unwrapped values when chaining
lodash.sample = collection.sample;

// add functions to `lodash.prototype`
mixin(assign({}, lodash));

/**
 * The semantic version number.
 *
 * @static
 * @memberOf _
 * @type string
 */
lodash.VERSION = VERSION;

lodash.support = support;
(lodash.templateSettings = string.templateSettings).imports._ = lodash;

// assign default placeholders
lodash.partial.placeholder = lodash;

// add "Chaining" functions to the wrapper
lodash.prototype.chain = chain.wrapperChain;
lodash.prototype.value = chain.wrapperValueOf;

// add `Array` mutator functions to the wrapper
arrayEach(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
  var func = arrayProto[methodName];
  lodash.prototype[methodName] = function() {
    var value = this.__wrapped__;
    func.apply(value, arguments);

    // avoid array-like object bugs with `Array#shift` and `Array#splice`
    // in Firefox < 10 and IE < 9
    if (!support.spliceObjects && value.length === 0) {
      delete value[0];
    }
    return this;
  };
});

// add `Array` accessor functions to the wrapper
arrayEach(['concat', 'join', 'slice'], function(methodName) {
  var func = arrayProto[methodName];
  lodash.prototype[methodName] = function() {
    var value = this.__wrapped__,
        result = func.apply(value, arguments);

    if (this.__chain__) {
      result = new lodashWrapper(result);
      result.__chain__ = true;
    }
    return result;
  };
});

module.exports = lodash;
