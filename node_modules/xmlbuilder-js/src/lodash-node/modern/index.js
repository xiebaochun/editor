/**
 * @license
 * Lo-Dash 3.0.0-pre (Custom Build) <http://lodash.com/>
 * Build: `lodash modularize modern exports="node" -o ./modern/`
 * Copyright 2012-2014 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
var array = require('./array'),
    chain = require('./chain'),
    collection = require('./collection'),
    func = require('./function'),
    lang = require('./lang'),
    object = require('./object'),
    string = require('./string'),
    utility = require('./utility'),
    arrayEach = require('./internal/arrayEach'),
    baseAssign = require('./internal/baseAssign'),
    baseForOwn = require('./internal/baseForOwn'),
    baseFunctions = require('./internal/baseFunctions'),
    isObject = require('./lang/isObject'),
    keys = require('./object/keys'),
    lodash = require('./chain/lodash'),
    lodashWrapper = require('./internal/lodashWrapper'),
    mixin = require('./utility/mixin'),
    support = require('./support');

/** Used as the semantic version number */
var VERSION = '3.0.0-pre';

/** Used for native method references */
var arrayProto = Array.prototype;

// wrap `_.mixin` so it works when provided only one argument
mixin = (function(func) {
  return function(object, source, options) {
    var isObj = isObject(source),
        noOpts = options == null,
        props = noOpts && isObj && keys(source),
        methodNames = props && baseFunctions(source, props);

    if ((props && props.length && !methodNames.length) || (noOpts && !isObj)) {
      if (noOpts) {
        options = source;
      }
      source = object;
      object = this;
    }
    return func(object, source, options);
  };
}(mixin));

// add functions that return wrapped values when chaining
lodash.after = func.after;
lodash.assign = object.assign;
lodash.at = collection.at;
lodash.before = func.before;
lodash.bind = func.bind;
lodash.bindAll = func.bindAll;
lodash.bindKey = func.bindKey;
lodash.callback = utility.callback;
lodash.chain = chain.chain;
lodash.chunk = array.chunk;
lodash.compact = array.compact;
lodash.constant = utility.constant;
lodash.countBy = collection.countBy;
lodash.create = object.create;
lodash.curry = func.curry;
lodash.curryRight = func.curryRight;
lodash.debounce = func.debounce;
lodash.defaults = object.defaults;
lodash.defer = func.defer;
lodash.delay = func.delay;
lodash.difference = array.difference;
lodash.drop = array.drop;
lodash.dropRight = array.dropRight;
lodash.dropRightWhile = array.dropRightWhile;
lodash.dropWhile = array.dropWhile;
lodash.filter = collection.filter;
lodash.flatten = array.flatten;
lodash.flattenDeep = array.flattenDeep;
lodash.flow = func.flow;
lodash.flowRight = func.flowRight;
lodash.forEach = collection.forEach;
lodash.forEachRight = collection.forEachRight;
lodash.forIn = object.forIn;
lodash.forInRight = object.forInRight;
lodash.forOwn = object.forOwn;
lodash.forOwnRight = object.forOwnRight;
lodash.functions = object.functions;
lodash.groupBy = collection.groupBy;
lodash.indexBy = collection.indexBy;
lodash.initial = array.initial;
lodash.intersection = array.intersection;
lodash.invert = object.invert;
lodash.invoke = collection.invoke;
lodash.keys = keys;
lodash.keysIn = object.keysIn;
lodash.map = collection.map;
lodash.mapValues = object.mapValues;
lodash.matches = utility.matches;
lodash.memoize = func.memoize;
lodash.merge = object.merge;
lodash.mixin = mixin;
lodash.negate = func.negate;
lodash.omit = object.omit;
lodash.once = func.once;
lodash.pairs = object.pairs;
lodash.partial = func.partial;
lodash.partialRight = func.partialRight;
lodash.partition = collection.partition;
lodash.pick = object.pick;
lodash.pluck = collection.pluck;
lodash.property = utility.property;
lodash.pull = array.pull;
lodash.pullAt = array.pullAt;
lodash.range = utility.range;
lodash.reject = collection.reject;
lodash.remove = array.remove;
lodash.rest = array.rest;
lodash.shuffle = collection.shuffle;
lodash.slice = array.slice;
lodash.sortBy = collection.sortBy;
lodash.take = array.take;
lodash.takeRight = array.takeRight;
lodash.takeRightWhile = array.takeRightWhile;
lodash.takeWhile = array.takeWhile;
lodash.tap = chain.tap;
lodash.throttle = func.throttle;
lodash.times = utility.times;
lodash.toArray = collection.toArray;
lodash.transform = object.transform;
lodash.union = array.union;
lodash.uniq = array.uniq;
lodash.unzip = array.unzip;
lodash.values = object.values;
lodash.valuesIn = object.valuesIn;
lodash.where = collection.where;
lodash.without = array.without;
lodash.wrap = func.wrap;
lodash.xor = array.xor;
lodash.zip = array.zip;
lodash.zipObject = array.zipObject;

// add aliases
lodash.backflow = func.flowRight;
lodash.collect = collection.map;
lodash.compose = func.flowRight;
lodash.each = collection.forEach;
lodash.eachRight = collection.forEachRight;
lodash.extend = object.assign;
lodash.iteratee = utility.callback;
lodash.methods = object.functions;
lodash.object = array.zipObject;
lodash.select = collection.filter;
lodash.tail = array.rest;
lodash.unique = array.uniq;

// add functions to `lodash.prototype`
mixin(lodash, baseAssign({}, lodash));

// add functions that return unwrapped values when chaining
lodash.attempt = utility.attempt;
lodash.camelCase = string.camelCase;
lodash.capitalize = string.capitalize;
lodash.clone = lang.clone;
lodash.cloneDeep = lang.cloneDeep;
lodash.contains = collection.contains;
lodash.endsWith = string.endsWith;
lodash.escape = string.escape;
lodash.escapeRegExp = string.escapeRegExp;
lodash.every = collection.every;
lodash.find = collection.find;
lodash.findIndex = array.findIndex;
lodash.findKey = object.findKey;
lodash.findLast = collection.findLast;
lodash.findLastIndex = array.findLastIndex;
lodash.findLastKey = object.findLastKey;
lodash.findWhere = collection.findWhere;
lodash.first = array.first;
lodash.has = object.has;
lodash.identity = utility.identity;
lodash.indexOf = array.indexOf;
lodash.isArguments = lang.isArguments;
lodash.isArray = lang.isArray;
lodash.isBoolean = lang.isBoolean;
lodash.isDate = lang.isDate;
lodash.isElement = lang.isElement;
lodash.isEmpty = lang.isEmpty;
lodash.isEqual = lang.isEqual;
lodash.isError = lang.isError;
lodash.isFinite = lang.isFinite;
lodash.isFunction = lang.isFunction;
lodash.isNaN = lang.isNaN;
lodash.isNative = lang.isNative;
lodash.isNull = lang.isNull;
lodash.isNumber = lang.isNumber;
lodash.isObject = isObject;
lodash.isPlainObject = lang.isPlainObject;
lodash.isRegExp = lang.isRegExp;
lodash.isString = lang.isString;
lodash.isUndefined = lang.isUndefined;
lodash.kebabCase = string.kebabCase;
lodash.last = array.last;
lodash.lastIndexOf = array.lastIndexOf;
lodash.max = collection.max;
lodash.min = collection.min;
lodash.noConflict = utility.noConflict;
lodash.noop = utility.noop;
lodash.now = utility.now;
lodash.pad = string.pad;
lodash.padLeft = string.padLeft;
lodash.padRight = string.padRight;
lodash.parseInt = utility.parseInt;
lodash.random = utility.random;
lodash.reduce = collection.reduce;
lodash.reduceRight = collection.reduceRight;
lodash.repeat = string.repeat;
lodash.result = utility.result;
lodash.size = collection.size;
lodash.snakeCase = string.snakeCase;
lodash.some = collection.some;
lodash.sortedIndex = array.sortedIndex;
lodash.sortedLastIndex = array.sortedLastIndex;
lodash.startsWith = string.startsWith;
lodash.template = string.template;
lodash.trim = string.trim;
lodash.trimLeft = string.trimLeft;
lodash.trimRight = string.trimRight;
lodash.trunc = string.trunc;
lodash.unescape = string.unescape;
lodash.uniqueId = utility.uniqueId;

// add aliases
lodash.all = collection.every;
lodash.any = collection.some;
lodash.detect = collection.find;
lodash.foldl = collection.reduce;
lodash.foldr = collection.reduceRight;
lodash.head = array.first;
lodash.include = collection.contains;
lodash.inject = collection.reduce;

mixin(lodash, (function() {
  var source = {};
  baseForOwn(lodash, function(func, methodName) {
    if (!lodash.prototype[methodName]) {
      source[methodName] = func;
    }
  });
  return source;
}()), false);

// add functions capable of returning wrapped and unwrapped values when chaining
lodash.sample = collection.sample;

baseForOwn(lodash, function(func, methodName) {
  var callbackable = methodName != 'sample';
  if (!lodash.prototype[methodName]) {
    lodash.prototype[methodName] = function(n, guard) {
      var chainAll = this.__chain__,
          result = func(this.__wrapped__, n, guard);

      return !chainAll && (n == null || (guard && !(callbackable && typeof n == 'function')))
        ? result
        : new lodashWrapper(result, chainAll);
    };
  }
});

/**
 * The semantic version number.
 *
 * @static
 * @memberOf _
 * @type string
 */
lodash.VERSION = VERSION;

lodash.support = support;
(lodash.templateSettings = string.templateSettings).imports._ = lodash;

// assign default placeholders
arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
  lodash[methodName].placeholder = lodash;
});

// add "Chaining" functions to the wrapper
lodash.prototype.chain = chain.wrapperChain;
lodash.prototype.toString = chain.wrapperToString;
lodash.prototype.toJSON = lodash.prototype.value = lodash.prototype.valueOf = chain.wrapperValueOf;

// add `Array` functions that return unwrapped values
arrayEach(['join', 'pop', 'shift'], function(methodName) {
  var func = arrayProto[methodName];
  lodash.prototype[methodName] = function() {
    var chainAll = this.__chain__,
        result = func.apply(this.__wrapped__, arguments);

    return chainAll
      ? new lodashWrapper(result, chainAll)
      : result;
  };
});

// add `Array` functions that return the existing wrapped value
arrayEach(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
  var func = arrayProto[methodName];
  lodash.prototype[methodName] = function() {
    func.apply(this.__wrapped__, arguments);
    return this;
  };
});

// add `Array` functions that return new wrapped values
arrayEach(['concat', 'splice'], function(methodName) {
  var func = arrayProto[methodName];
  lodash.prototype[methodName] = function() {
    return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
  };
});

module.exports = lodash;
